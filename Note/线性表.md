## 线性表

什么是线性表？
* **相同数据类型** 数据元素的 **有限序列**
$$
L(a{_1},a{_2},a{_3},a{_4}...,a{_n})
$$
* $a{_1}和a{_n}$是线性表的 **表头元素和表尾元素**
* 除了上述两个元素外，其余元素 **有且仅有一个前驱、一个后继**
* 特点：
  * 个数有限
  * 逻辑上有序
  * 表中元素数据 **类型相同**，占有 **相同大小** 的内存空间


---
## 顺序表 —— 线性表的顺序表示

1. 什么是顺序表？
   * 内存中开辟一块 **连续的存储单元** 存储数据
   * **逻辑顺序和物理顺序相同**
2. 什么是位序？
   * 描述线性表中元素在线性中的位置 
   * 范围：**1~n**
   * **注意和下表区分，下标：0~n-1**
3. 顺序表是一种 **随机存取结构**
4. 顺序表的操作
   * 定义
     * 静态
        ```c++
        # define MaxSize 10
        typedef struct{
            //顺序表存放的元素类型
            ElemType data[MaxSize];
            //表长度
            int length;
        }SeqList;
        ```
     * 动态
        ```c++
        # define InitSize 10
        typedef struct{
            ElemType *data;
            int length;
        }SeqList;
        ```
   * 初始化
     * 静态
        ```c++
        bool InitSeqList(SeqList &L){
            int L.length = 0;
        }
        ```
     * 动态
        ```c++
        bool InitSeqList(SeqList &L){
            //采用malloc在内存中申请空间
            L.data = (ElemType*)malloc(sizeif(ElemType)*InitSize);
            L.length = 0;
        }
        ```
   * 插入
        ```c++
        bool ListInsert(SeqList &L,int i ,int e){
            //判断插入位置是否合法
            if(i<1||i>L.length+1){
                return false;
            }
            //判断当前表是否还剩余空间
            if(L.length>=MaxSize){
                return false;
            }
            for(int j = L.length;j>=i;j--){
                L.data[j]=L.data[j-1];
            }
            L.data[i-1] = e;
            L.lrngth++;
            return true;
        }
        ```
   * 删除
        ```c++
        bool ListDelete(SeqList &L,int i,int &e){
            if(i<1||i>L.length){
                return false;
            }
            e = L.data[i-1];
            for(int j = i;j<L.length;j++){
                L.data[j-1]=L.data[j];
            }
            L.length--;
            return true;
        }
        ```
    * 查找
      * 按位查找
         ```c++
         ElemType findByLocation(SeqList &L,int Loc){
             return data[Loc-1];
         }
         ``` 
      * 按值查找
        ```c++
        int findByElement(SeqList &L, Elemtype Element){
            for(int i = 0;i<L.length;i++){
                if(L.data[i]==e){
                     return i+1;
                }
            }
            return -1;           
    
        }
        ```

5. 总结
    * 插入操作 
      * 最好：$O(1)$
      * 最坏：$O(n)$
      * 平均：$O(n)$
    * 删除操作
      * 最好：$O(1)$
      * 最坏：$O(n)$
      * 平均：$O(n)$
    * 按位查找
      * 最好：$O(1)$
      * 最坏：$O(1)$
      * 平均：$O(1)$
      * **因为顺序表是随机存储的存储结构**
    * 按值查找
      * 最好：$O(1)$
      * 最坏：$O(n)$
      * 平均：$O(n)$


 ---
 ## 链表 —— 线性表的链接表示 
 